# Ветка `Module№1`

# 1.3. Проверка битов
Если в числе содержится только один бит со значением 1, записать в выходной поток OK.
Иначе записать FAIL.
Необходимо использование битовых операций.
Использование арифметических операций запрещено.

### Формат ввода
Входное число лежит в диапазоне 0..232-1 и вводится в десятичном виде.

### Формат вывода
Строка OK или FAIL


# 2.1. Следующий элемент

Дан отсортированный массив целых чисел A[0..n-1] и массив целых чисел B[0..m-1]. Для каждого элемента массива B[i] найдите минимальный индекс k минимального элемента массива A, равного или превосходящего B[i]: A[k] >= B[i]. Если такого элемента нет, выведите n. Время работы поиска k для каждого элемента B[i]: O(log(k)). n, m ≤ 10000.

### Формат ввода
В первой строчке записаны числа n и m. Во второй и третьей массивы A и B соответственно.

# 3.2. Дек с динамическим буфером

Реализовать дек с динамическим зацикленным буфером.

Обрабатывать команды push * и pop *.

### Формат ввода
В первой строке количество команд n. n ≤ 1000000.

Каждая команда задаётся как 2 целых числа: a b.

a = 1 - push front
a = 2 - pop front
a = 3 - push back
a = 4 - pop back
Если дана команда pop *, то число b - ожидаемое значение. Если команда pop * вызвана для пустой структуры данных, то ожидается “-1”.

# 4.1. Слияние массивов

Напишите программу, которая использует кучу для слияния K отсортированных массивов суммарной длиной N.

### Требования:

Время работы O(N * logK)
Куча должна быть реализована в виде шаблонного класса.
Решение должно поддерживать передачу функции сравнения снаружи.
Куча должна быть динамической.
### Формат ввода
Сначала вводится количество массивов K.
Затем по очереди размер каждого массива и элементы массива.
Каждый массив упорядочен по возрастанию.

### Формат вывода
Итоговый отсортированный массив.

# 6. Порядковая статистика и параметры множества

Дано множество целых чисел из [0..109] размера n.
Используя алгоритм поиска k-ой порядковой статистики, требуется найти следующие параметры множества:
10% перцентиль
медиана
90% перцентиль
### Требования:

К дополнительной памяти: O(n).
Среднее время работы: O(n)
Должна быть отдельно выделенная функция partition.
Рекурсия запрещена.
Решение должно поддерживать передачу функции сравнения снаружи.
Формат ввода
Сначала вводится кол-во элементов массива n. После сам массив.

### Формат вывода
Параметры множества в порядке:

10% перцентиль
медиана
90% перцентиль

# 7.3. Binary MSD для long long

Дан массив неотрицательных целых 64-разрядных чисел. Количество чисел не больше 1000000. Отсортировать массив методом MSD по битам (бинарный QuickSort).

# Ветка `Module№2`

# 1. Хеш-таблица

Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.
Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера. Начальный размер таблицы должен быть равным 8-ми. Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.
Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.

### Вариант 1.
Для разрешения коллизий используйте квадратичное пробирование.
i-ая проба g(k, i)=g(k, i-1) + i (mod m). m - степень двойки.

# 2_3. Обход дерева в порядке post-order

Дано число N ≤ 104 и последовательность целых чисел из [-231..231] длиной N. Требуется построить бинарное дерево, заданное наивным порядком вставки. Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root. Выведите элементы в порядке post-order (снизу вверх).

Рекурсия запрещена.

# 3. B-дерево

Постройте B-дерево минимального порядка t и выведите его по слоям.
В качестве ключа используются числа, лежащие в диапазоне [0..232-1]
### Требования:

B-дерево должно быть реализовано в виде шаблонного класса.
Решение должно поддерживать передачу функции сравнения снаружи.
### Формат ввода
Сначала вводится минимальный порядок дерева t.
Затем вводятся элементы дерева.

### Формат вывода
Программа должна вывести B-дерево по слоям.
Каждый слой на новой строке, элементы должны выводится в том порядке, в котором они лежат в узлах.

# 4_1. Солдаты

В одной военной части решили построить в одну шеренгу по росту. Т.к. часть была далеко не образцовая, то солдаты часто приходили не вовремя, а то их и вовсе приходилось выгонять из шеренги за плохо начищенные сапоги. Однако солдаты в процессе прихода и ухода должны были всегда быть выстроены по росту – сначала самые высокие, а в конце – самые низкие. За расстановку солдат отвечал прапорщик, который заметил интересную особенность – все солдаты в части разного роста. Ваша задача состоит в том, чтобы помочь прапорщику правильно расставлять солдат, а именно для каждого приходящего солдата указывать, перед каким солдатом в строе он должен становится. Требуемая скорость выполнения команды - O(log n).

### Формат ввода
Первая строка содержит число N – количество команд (1 ≤ N ≤ 90 000). В каждой следующей строке содержится описание команды: число 1 и X если солдат приходит в строй (X – рост солдата, натуральное число до 100 000 включительно) и число 2 и Y если солдата, стоящим в строе на месте Y надо удалить из строя. Солдаты в строе нумеруются с нуля.

### Формат вывода
На каждую команду 1 (добавление в строй) вы должны выводить число K – номер позиции, на которую должен встать этот солдат (все стоящие за ним двигаются назад).

# 5. Алгоритм сжатия данных Хаффмана

Напишите две функции для создания архива из одного файла и извлечения файла из архива.

Метод архивирует данные из потока original
`void Encode(IInputStream& original, IOutputStream& compressed);`
Метод восстанавливает оригинальные данные
`void Decode(IInputStream& compressed, IOutputStream& original);`
где:
```
typedef char byte;

interface IInputStream {
// Возвращает false, если поток закончился
virtual bool Read(byte& value) = 0;
};

interface IOutputStream {
virtual void Write(byte value) = 0;
};
```
В архиве сохраняйте дерево Хаффмана и код Хаффмана от исходных данных. Дерево Хаффмана требуется хранить эффективно - не более 10 бит на каждый 8-битный символ.

В контест необходимо отправить .cpp файл содержащий функции Encode, Decode, а также включающий файл Huffman.h. Тестирующая программа выводит размер сжатого файла в процентах от исходного.

Пример минимального решения:
```
#include "Huffman.h"

static void copyStream(IInputStream&input, IOutputStream& output) {
byte value;
while(input.Read(value)) { output.Write(value); }
}

void Encode(IInputStream& original, IOutputStream& compressed) {
copyStream(original, compressed);
}

void Decode(IInputStream& compressed, IOutputStream& original) {
copyStream(compressed, original);
}
```
# Ветка `Module№3`

